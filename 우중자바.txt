♥♥♥♥♥♥♥♥♥♥♥1일차♥♥♥♥♥♥♥♥♥♥
변수
 - 변수 선언을 할 수 있다
 - 변수의 값을 콘솔에 출력할 수 있다.
 - 콘솔에서 입력받아 변수에 값을 저장할 수 있다.

변수타입 변수명 = 값;
변수타입 종류
 - 정수 : byte, short, int long, char
 - 실수 : float, double
 - 논리 : boolean
 - 문자열 : String
타입변환
 - 자동
 - 강제
콘솔 출력 : println
콘솔 입력 : Scanner


♥♥♥♥♥♥♥♥♥2일차♥♥♥♥♥♥♥♥♥♥♥♥


연산자
- 연산자 종류와 그에 따른 결과를 예측할 수 있다
- 연산자 종류

- 증감연산자 : 숫자
  - 최종적으로 1증가/1감소 =>
    전위형/후위형에 상관없이 연산이 끝난 다음에 변수의 값이 1증가/1감소
  - 전위형 : ++변수명, 증가하고 동작
  - 후위형 : 변수명++, 동작하고 증가

- 산술연산자 : 숫자
  - / : 정수 / 정수 => 정수(소수점이 사라짐)
  - 타입 변환을 통해 정수 / 정수를 실수 / 정수로 변환 후 계산
  - % : 나누었을 때 나머지가로 표현되면 사용

- 비교연산자 : 참 또는 거짓
  - 크기 비교

- 논리연산자 : 참 또는 거짓
  - && : ~하고, 둘다 참인경우만 참, 나머진 거짓
  - ||    : ~하거나, 둘다 거짓인 경우만 거짓, 나머진 참
  - !     : 반대, 참이면 거짓, 거짓이면 참

- 조건선택연산자 : 알수 없음(숫자, 참 또는 거짓 모두 가능)

조건문
- 조건문의 종류와 사용법을 익힌다.
- 조건문을 언제 사용하는지 이해할 수 있다.
- ~하면 ...해라
  ~ : 조건식, 면 앞부분이 조건식
  ... : 실행문, 면 뒷부분이 실행문
- if문, switch문
- if문 기본 문법1
if(조건식){
	실행문;
}
- 조건식이 참이면 실행문을 실행하고, 조건식이 거짓이면 아무것도 안함

- if문 기본 문법2
if(조건식){
	실행문1;
} else {
	실행문2;
}
- 조건식이 참이면 실행문1을 실행하고, 조건식이 거짓이면 실행문2를 실행

- 기본 문법3
if(조건식1){
	실행문1;
} else if(조건식2){
	실행문2;
} else{
	실행문3;
}
- 조건식1이 참이면 실행문1을 실행하고,
  조건식1이 거짓이고 조건식2가 참이면 실행문2를 실행하고,
  조건식1과 조건식2가 모두 거짓이면 실행문3을 실행해라

- if문에서 else나 else if는 있을 수도 있고 없을 수도 있지만 if는 필수!


♥♥♥♥♥♥♥♥♥3일차♥♥♥♥♥♥♥♥♥♥♥♥

1. 변수
 - 변수 선언을 할 수 있다.
 - 변수를 콘솔에 출력할 수 있다.
 - 콘솔에서 입력받아 변수에 저장할 수 있다.

 - 변수 선언 방법
타입 변수명;
타입 변수명 = 값;
타입 변수명1, 변수명2;
 - 타입 종류
  - 정수    : int, char
  - 실수    : float, double
  - 논리형 : boolean
  - 문자열 : String
 - 변수명 작성 규칙(필수)
 - 변수명 작성 관례(필수x)
 - System.out.println
 - Scanner

2. 연산자
 - 연산자 종류를 알고, 그 결과를 예측할 수 있다.
 - 산술(+-*/%) : 숫자
  - / : 정수 / 정수 => 정수(소수점이 버려짐)
  - 강제 타입 변환을 이용하여 소수점을 살림
  - % : 나머지를 구하는 연산자
  - /, %는 0으로 나누면 안됨
 - 비교 : <, >, <=, >=, ==, !=
  - =와 ==를 혼동하지 말자
  - 결과가 참 또는 거짓
 - 조건식 : 결과가 참 또는 거짓이 되는 식
 - 논리 : &&, ||, ! 
  - && : ~하고, 둘다 참이면 참, 나머진 거짓
  - || : ~하거나, 둘다 거짓이면 거짓, 나머진 참
  - ! : 반대, 참이면 거짓, 거짓이면 참
 - 증감연산자 : 정수
  - 최종적으로 1증가/1감소
  - 전위형 : ++변수명,--변수명, 증가/감소하고 동작
  - 후위형 : 변수명++,변수명--, 동작하고 증가/감소
 - 대입연산자 : = 
  - 오른쪽에 있는 값을 왼쪽에 저장
  - 왼쪽에는 변수가 1개와야 한다
 - 조건선택연산자 : (조건식) ? 참 : 거짓;

3. 조건문
 - 조건문을 사용해야 하는 상황을 알고, 조건문을 사용할 수 있다.
 - 상황에 따라 결과가 달라질 때 조건문을 사용
 - ~하면 ...해라
 - 모든 조건문은 if문으로 표현 가능
 - if문, switch문
 - if문 기본문법
 - 조건식1이 참이면 실행문1을 실행하고, 
   조건식1이 거짓이고 조건식2가 참이면 실행문2를 실행하고,
   조건식1, 조건식2가 모두 거짓이면 실행문3을 실행해라
 - else : 현재 위치를 기준으로 위에 있는 조건식이 거짓이면으로 해석
if(조건식1){
	실행문1;
} else if(조건식2){
	실행문2;
} else{
	실행문3;
}	

 - 이중 if문
  - if문의 실행문으로 if문이 또 오는 경우
  - 이중 if문은 단일 if문으로도 표현할 수 있다
if(조건식1){
	if(조건식2){
		실행문;
	}
}

if(조건식1 && 조건식2){
	실행문;
}

- switch문 
 - 사용하는 변수의 값이 제한적일 때
  - 산술연산 예제, 월의 마지막일 출력 예제
 - 문법

switch(변수나 식){
case 값1:			if(변수 == 값1)
	실행문1;		
	break;
case 값2:			else if(변수 == 값2)
	실행문2;
	break;
default:			else
	실행문3;
}

 - case 값으로는 정수형값과 문자열만 가능
 - ==로는 문자열을 비교할 수 없다

반복문
 - 규칙적인 작업을 반복적으로 할 때 반복문을 사용
 - 규칙과 반복횟수
 - for문, while문, do while문
 - for문 문법
for(1.초기화; 2.5.8.조건식 ; 4.7.증감식){
	3.6.실행문;
}
 - 초기화 : for문 실행 시 1번만 실행, 조건식이나 실행문에서 사용하는 변수를
              초기화, 생략 가능
 - 조건식 : 조건식이 참이면 반복문이 동작, 거짓이면 반복문이 종료
              => 반복문은 조건식이 거짓이 될때까지 반복,
              생략 가능, 생략하면 조건식은 무조건 참으로 판별
 - 증감식 : 조건식, 실행문에서 사용하는 변수를 증가/감소시킴, 생략가능

홍길동 1~10까지 외치라고 함
초기화 : 홍길동 학생이 외칠 숫자를 1로 초기화
조건식 : 홍길동 학생이 외칠 숫자가 10보다 작거나 같을때까지
실행문 : 홍길동 학생이 외칠 숫자를 외침
증감식 : 홍길동 학생이 외칠 숫자를 1증가



♥♥♥♥♥♥♥♥♥4일차♥♥♥♥♥♥♥♥♥♥♥♥


for(1.초기화 ; 2.조건식 ; 4.증감식 ){
	3.실행문
}
1. 초기화 : 변수 초기화, 주로 조건식이나 실행문에서 사용하는 변수를 초기화,
               생략 가능
2. 조건식 : 반복문 동작여부를 결정, 참이면 실행, 거짓이면 반복뭉 종료,
               생략 가능, 생략하면 무조건 참
4. 증감식 : 변수를 증가/감소, 조건식이나 실행문에서 사용하는 변수를 증가/감소,
               생략 가능
반복횟수는 초기화, 조건식, 증감식을 결정해준다
규칙성은 실행문이다
반복문 종료 후는 출력용(확인용)

- break
 - switch문이나 반복문을 빠져 나가게 하는 키워드
 - 반복문에서 break는 if문과 항상 같이 나온다.
   => if문과 같이 안쓰이면 반복문을 안쓴거랑 같기 때문에

- continue
 - 스킵, 특정 위치로 이동
 - for문에서 continue는 증감식 위치로 이동, while문에서 조건식으로 이동
 - 항상 if문과 같이 쓰임
   =>if문 같이 안쓰이면 continue 아래 코드를 지운거랑 같음

중첩 for문(이중 for문)
 - for문의 실행문으로 for문이 오는 경우
for( ; ; ){
	for( ; ; ){
		실행문;
	}
}



♥♥♥♥♥♥♥♥♥5일차♥♥♥♥♥♥♥♥♥♥♥♥


- while문 문법
while(조건식){
	실행문;
}

초기화;
while(조건식){
	실행문;
	증감식;
}
- while문에서 조건식은 생략 불가능
- 모든 반복문은 for으로 표현 가능하다
- 모든 반복문은 while문으로 표현 가능하다
- for문 while문 둘 중에 하나만 잘 써도 된다
- 강사는 주로 반복하는 숫자가 일정하게 증가하거나 반복횟수가 정해져 있는 경우 
  for문을 사용
- 강사는 주로 반복횟수가 정해져 있지 않은 경우 while문을 사용

- do while문 문법

do{
	실행문;
}while(조건식);

 - do while문은 무조건 1번은 됨
 - do while문은 최소 1번은 실행되어야 할 때 사용
 - 영문자 입력 예제

for( ; ; ){
	for( ; ; ){
		if(){
			//아래 break를 만나면 A로 이동
			break;
		}
	}
	//A
}
//B

Label1 : for( ; ; ){
	for( ; ; ){
		if(){
			//아래 break를 만나면 B로 이동
			break Label1;
		}
	}
	//A
}
//B

반복문
- 반복문 종류(for, while, do while)
- 언제 사용? 규칙적인 작업을 반복할 때
- 반복횟수, 규칙성, 반복문 종료 후 작업으로 나눠서 연습

- 참조타입
- 정수형, 실수형, 논리형은 기본타입
- 문자열은 참조타입
- 기본 타입은 값을 저장
- 참조 타입은 주소를 저장
- 기본타입이 아닌 모든 타입은 참조타입이다\
- 참조변수에서 ==와 !=는 주소를 비교하기 때문에 실제 값이 같더라도 주소가 
  다르면 다르다고 판단한다
- 참조변수는 일반적으로 초기값을 null로 지정
- null : 객체를 참조하지 않는다는 의미

- 리터럴 : 1, 'a', 1.23, 실제 값(코드에서 사용하는 값)
- 참조변수 = 주소

- 배열
 - 배열을 생성할 수 있다.
 - 반복문을 이용하여 배열을 관리할 수 있다.

 - 배열 : (같은 의미) + 같은 타입의 변수들을 모아 놓은 것
//아래는 성적이라는 의미로 묶을 수 있기 때문에 배열로 만들어서 사용
int stdScore1, stdScore2, .. stdScore30;
//아래는 타입은 같지만 의미를 묶을 수 없기 때문에 배열로 안만드는것이 낫다
int appleCount, stdScore, age;

 - 배열 선언 방법
타입 배열명[];
타입 [] 배열명;
타입 배열명[] = new 타입[크기];	//추천
타입 배열명[] = {값1, 값2, 값3, ...};
타입 배열명[] = new 타입[]{값1, 값2, 값3, ..};

int array1[] = null;
int []array2 = null;

- 객체 : new 연산자를 통해 만들어진 저장 공간
- 변수 : 일반 타입으로 만들어진 저장 공간
- 배열의 시작 번지는 0번지부터 시작, 마지막번지는 크기-1
- 배열의 값 가져오기
  배열명[번지]
  - 배열의 첫번째 값을 가져오고 싶다
    => 배열의 0번지의 값을 가져오고 싶다
    => 배열명[0]
- 배열의 길이는 배열명.length로 알수 있다

숫자 야구 게임
 - 1 ~ 9 사이의 중복되지 않은 3개의 정수를 랜덤으로 생성
 - B : 숫자는 있지만 위치는 다른 경우
 - S : 숫자도 있고, 위치가 같은 경우
 - O : 일치하는 숫자가 하나도 없는 경우
예시 : 3 9 5
입력 하세요 : 1 2 3
1B
입력 하세요 : 4 5 6
1B
입력하세요 : 3 4 5
2S
입력하세요 : 3 5 9
1S2B
입력하세요 : 6 7 8
O
입력하세요 : 3 9 5
3S
정답입니다.




♥♥♥♥♥♥♥♥♥6일차♥♥♥♥♥♥♥♥♥♥♥♥



1. 변수
 - 목표 : 변수를 선언할 수 있다.
 - 데이터를 관리하기 위해
 - 변수 선언 방법
 - 타입 종류
 - 콘솔 입출력

2. 연산자
 - 목표 : 연산자 종류와 그에 따른 결과를 예측할 수 있다.
 - 산술 연산자 : 숫자(정수, 실수) op
 - 비교 연산자 : 논리(참 또는 거짓)
 - 논리 연산자 : 논리(참 또는 거짓)
 - 조건 선택 연산자 : 미정(정수, 실수, 논리, 문자열 다 가능)
 - 증감 연산자 : 숫자
 - 대입 연산자 : 값

3. 조건문
 - 조건문 : 조건문을 사용할 수 있다.
 - 조건문 종류(if문, switch문)
 - ~하면 ...해라
 - ~ : 조건식, ... : 실행문

4. 반복문
 - 목표 : 규칙적으로 반복하는 작업을 반복문으로 만들 수 있다.
 - 반복문 종류 : for, while, do while
 - 반복횟수, 규칙성, 반복문 종류 후로 나누어서 연습

5. 배열
 - 목표 : 배열을 선언하고 사용할 수 있다.
 - 배열 선언 방법
 - 배열 특징
  - 배열의 시작 번지는 0번지
  - 배열의 마지막 번지는 크기-1 번지
 - 배열은 반복문과 같이 사용
 - 많은 변수들을 효율적으로 관리하기 위해 배열을 사용

6. 열거형
 - 목표 : 열거형을 만들고 사용할 수 있다.
 - 상수에 이름을 붙이는 것
 - 열거타입 선언
   enum 열거형명 { 이름1, 이름2, 이름3,... }
 - 열거 타입 변수 선언
   열거형명 변수명;
   열거형명 변수명 = 열거형명.이름1;

자바
 - 객체지향 프로그래밍 언어(OOP)
 - 순서대로 동작
 - 객체에 초점을 맞춤

C언어
 - 절차지향 프로그래밍 언어
  - 순서에 초점을 맞춤

- 설문지를 인쇄

- 절차
  - 인쇄하는 기능을 이용하여 인쇄

- 객체
  - 인쇄를 하기 위한 프린터 설계도(클래스)를 만듬
  - 설계도를 이용하여 프린터(인스턴스, 객체)를 생성
  - 프린터를 이용하여 인쇄

- 클래스
  - 멤버 변수(정보들)
  - 멤버 메소드(기능들)
  - 생성자(초기화)

- 자동차
  - 멤버 변수 : 바퀴 수, 와이퍼갯수, 회사명, 차종, 차명, 시동(켜졌는지 꺼졌는지)
    속력, 기어 등
  - 멤버 메소드 : 시동 켜기, 끄기, 와이퍼 켜기, 끄기, 속력 UP/속력 DOWN 등
  - 생성자 : 바퀴수 4, 와이퍼 갯수 2, 기아, 소형차, k5, 꺼짐, 0, 파킹

- 클래스
  - 클래스 선언
class 클래스명{
	멤버변수들;
	멤버메소드들;
	생성자;
}
  - 클래스명 작성 규칙은 변수명 작성 규칙과 동일
  - 클래스명 작성 관례
    - 클래스명의 첫글자는 대문자

  - 객체 선언
클래스명 객체명;
  - 객체 생성
클래스명 객체명 = new 클래스명();

 - 멤버 변수와 일반 변수의 차이점
   - 일반 변수는 자동으로 초기화 되지 않음
   - 멤버 변수는 자동으로 초기화 됨
 - 멤버 변수 사용
객체명.멤버변수명 = 값;

 - 생성자 
   - 멤버 변수들을 초기화 하는 곳
   - 모든 클래스는 생성자가 필수
   - 클래스에 생성자 코드가 없다면 자동으로 기본 생성자가 추가 됨

 - 기본 생성자 : 클래스에서 생성자가 하나도 없으면 기본 생성자가 자동으로 만들어져서
   호출 됨
public 클래스명(){

}
 - 생성자 
public 클래스명(타입 변수명1, 타입 변수명2, ...){
	멤버변수명1 = 변수명1;
	멤버변수명2 = 변수명2;
	...
}

 - 메소드 : 기능을 모아놓은 코드

음료수 자판기	메소드
돈, 메뉴		매개변수(인자)
음료수		리턴타입

 - 일을 시키려면 제대로된 정보를 전달 => 매개변수

중국집에서 배달
배달		메소드
주소, 메뉴		매개변수
요리		리턴타입

 - 메소드 선언 방법
리턴타입 메소드명(매개변수){
	구현;
	return 값;
}

음료수 음료수자판기(int 돈, String 메뉴){
	구현;
}
 - 리턴타입 : 결과물을 묶을 있는 타입을 씀

 - 메소드 생성 할 때, 다음을 정리
  1. 기능 : 기능을 상세하게 설명
  2. 매개변수 : 기능을 실행하기 위 해 꼭 필요한 정보들을 매개변수로 만듬
  3. 리턴타입 : 기능을 실행 후 알려주는 정보를 리턴타입으로 설정
  4. 메소드명 : 적절한 단어를 이용하여 메소드명을 생성

 - 메소드는 상황에 따라서 return 값이 없을 수 있다
 - 리턴타입이 없는 경우는 void라는 키워드로 대체

 - 메소드의 매개변수는 변수 선언 시 값이 복사가 된다

 - 매개변수가 일반변수인 경우 원본 값이 변하지 않음
 - 매개변수가 참조변수인 경우 원본 값이 변할수 있음
 - 일반변수 : 타입이 기본타입인 경우
                 값을 저장하는 변수
 - 참조변수 : 타입이 기본타입이 아닌 경우, 배열, 열거형, 객체
                 값이 아닌 주소를 저장하는 변수

 - 메소드를 왜 사용하는가?
   - 재사용을 통해 코드의 길이를 줄이기 위해
   - 기능의 유지보수가 쉬워진다
   - 코드의 구조를 파악하기 쉬워진다

♥♥♥♥♥♥♥♥♥10일차♥♥♥♥♥♥♥♥♥♥♥♥

클래스 프린터 설계도
객체 프린터
등록 된 프린터 정보 : 프린터 명, 전원, 빨강 잉크 양, 파랑 잉크 양 등
프린터 프린터 기능 : 칼라 프린트, 흑백 프린트, 양면 프린트
			전원 온 / 오프 등

학생 관리 프로그램 : 학생 성적 관리
학생 300 명의 정보 (학년, 반, 번호, 이름, 국어, 영어, 수학 성적)를 관리
int [] grade = 새로운 int [300];
int [] classNum = 새로운 int [300];
int [] num = 새로운 int [300];
문자열 [] 이름 = 새 문자열 [300];

Student [] std = new Student [300];

클래스
-멤버 면역 : 정보
-메소드 : 기능
-생성자 : 정보의 초기 값 설정

좌표 평면의 점을 클래스 클래스
-멤버 내 : x 좌표, y 좌표
-메소드 : xy 좌표 출력 기능, 좌표 이동 기능

자동차 클래스
-멤버 함수 : 함수, 차종, 바퀴 수, 와이퍼, 기어, 자동 / 수동 등
-메소드 : 시동, 와이퍼 동작, 주차, 전진 / 후진

게시판
-멤버 콘텐츠 : 제목, 내용, 작성자, 작성 시간, 추천, 추천 / 비추천 

회원
-멤버 가입 : 아이디, 비밀번호, 이메일, 휴대폰 번호, 성별 등

class 클래스 명 {
접근 제 한자 멤버 내성;
접근 제 한자 메소드;
공개 생성자;
}

접근 제 한자
-공개 : 본인 + 같은 패키지 + 마이너스 클래스 + 다른 패키지 => 전체 (공개)
-protected : 본인 + 같은 패키지 + 설명 클래스 (상속에서 다시) 
-(기본값) : 본인 + 같은 패키지 (지인)
-개인 : 본인 (나) 
  => 본인 클래스에서 호출이 가능
  => 본인 클래스의 메소드에서만 사용이 가능
  => 다른 클래스에서는 사용할 수 없습니다

-클래스가 public 이려면 클래스 명과 파일명이 같다.
  다르면 public을 붙일 수 없음

-클래스의 멤버 변수 접근 방법
획득 명. 멤버 면역 명

-일반적으로 대부분의 멤버 변수는 개인용입니다.
  => 멤버의 값을 직접 수 없다
  => 멤버라는 값을 공개적으로 만들어져있다.
       해당 메소드를 getter와 setter라고 부른다.
      getter는 private으로 된 멤버의 값을 확인하는 메소드
      setter는 private으로 된 멤버 변수의 값을 설정하는 메소드
  => 정보 수정은 어떤 기능을 통해 구성되어야하기 때문에
-일반적으로 대부분의 멤버 메소드는 공개적으로 사용됩니다.

-클래스
  -멤버 변수
  -멤버 메소드
  -생성자

접근 제 한자 클래스 클래스 명 {
	접근 제 한자 멤버 내성;
	접근 제 한자 멤버 메소드;
	public 생성자 () {

	}
}

2 차원 좌표 평면의 점을 클래스 클래스 : Point
멤버 변수 : x 좌표, y 좌표
멤버 메소드 : 좌표를 출력하는 기능, 좌표를 이동하는 기능

설계도 => 클래스
프린터 => 객체

-선언 방법
클래스 명 객체; // 실제 만들어진 건 아니고, 만들어 질 예정 (객체 선언)
클래스 명 생성 = new 클래스 명 (); // 실제 만들어 짐 (객체 선언과 동시에)

-도형 원을 클래스로 만드려고한다
  -멤버 변수 : 중심점 (x 좌표, y 좌표), 반지름
  -멤버 메소드 : 원 정보 출력, 중심점 이동, 반지름 변경
-위의 내용을 포함하는 Circle 클래스를 생성하고 멤버를 선언합니다.

-생성자 : 멤버를 초기화하는 곳
  -모든 클래스는 생성되어야합니다.
  -클래스에 생성자가 기본 생성자가 자동으로 만들어진다.
  -클래스에 생산자는 자동으로지지 않습니다.
  -메소드에서 리턴 타입이없고 (void 아님), 메소드 명이 클래스 명과 동일

-기본 생성자
공용 클래스 명 () {
	멤버 변수 초기화;
}
-생성자
public 클래스 명 (매개 국내) {
	멤버 초기화;
}

-원 (원)
  -멤버 내 : 중심점, 반지름

-직각 사가 형 (Rect)
  -멤버 위 : 점 2 개 (왼쪽 아래 점)
                   너비, 높이

♥♥♥♥♥♥♥♥♥11일차♥♥♥♥♥♥♥♥♥♥♥♥

클래스 만드는 과정
1. 멤버변수
2. 생성자
3. 멤버메소드

한국인 클래스
멤버변수 : 이름 성별 주민번호 나이 주소 등

상품 클래스
멤버변수 : 카테고리, 상품명, 재고량, 판매량, 가격 등

접근제한자
-public : 본인 + 같은 + 자식 + 다른
-protected : 본인 + 같은 + 자식
-(default) : 본인 + 같은
-private : 본인 

생성자
- 멤버변수 초기화 : 일반 변수인 경우 초기값을 설정하고, 참조 변수인 경우 객체를 생성
- 생성자의 이름은 클래스명과 같다
- 리턴타입 없다
 - 잘된 예
public 클래스명(){}
 - 잘못된 예
public void 클래스명(){} // 생성자가 아니라 메소드
- 생성자는 객체를 생성할 때 자동으로 호출된다
- 생성자는 임의로 호출할 수 없다
Point pt = new Point();
pt.Point();// 생성자를 이렇게 호출 할 수 없다
- 생성자가 없는 경우 기본 생성자가 만들어진다.
- 생성자는 여러개 있을 수 있다. => 생성자 오버로딩
- 생성자 오버로딩은 매개변수의 종류가 다른 경우 만들 수 있다
 - 매개변수의 갯수가 다른경우 가능
 - 매개변수의 타입이 다른 경우 가능
-복사생성자
public 클래스명 (클래스명 객체명){}

this 객체
-클래스 안에서만 사용(멤버 메소드, 생성자에서 사용 가능)
-객체인데 나를 의미
-매개변수의 이름과 멤버 변수의 이름이 같은 경우 필수로 사용
-this() : 해당 클래스의 생성자
 this() 생성자는 생성자안에서 첫줄에 와야한다.

오버로딩
-같은 이름의 메소드/생성자가 여러개인 경우
-매개변수가 다른 경우에 가능
 - 매개변수의 갯수가 다른 경우
 - 매개변수의 갯수가 같지만 타입이 다른 경우
-생성자 오버로딩
-메소드 오버로딩


-기본 타입 변수            -기본타입이 아닌 변수
- 값                          -주소
- int, char, double ...      -배열,String, 클래스, 열거형 등


멤버변수                  vs       지역변수
-해당 클래스 안 전체        -변수가 선언된 위치에서 포함된 범위

객체 멤버 변수                  클래스 멤버 변수(정적 멤버 변수,static이 붙은)
-멤버변수를 호출할 때          -멤버변수를 호출할 때 클래스이름으로 호출
-객채이름으로 호출
-객체명,멤버변수명              - 클래스명,멤버변수명(객체명,멤버변수명도 가능)
-static 없음                       - static 있음
-객체 하나씩 존재               -클래스당 하나(모든 객체가 공유)


기아 자동차 클래스
-멤버변수 : 제조사, 차 명, 생산량(기아자동차 생산량)
 - 객체 멤버변수 : 차 명
 - 클래스 멤버변수 :  제조사

객체멤버 메소드            vs         클래스멤버메소드
-static 없음                             -static 있음
-객체,메소드명()으로 호출            -클래스,메소드명으로 호출(math.random())
-각 객체마다 메소드를 가지고 있음 -하나의 클래스가 메소드를 가지고 있음


클래스 멤버 변수/메소드와 객체 멤버 변수/메소드의 사용시 유희 사항
-클래스 멤버변수/메소드는 객체 메소드에서 사용 가능
-클래스 멤버변수는 클래스 메소드에서 사용 가능
-객체 멤버변수/메소드는 클래스 메소드에서 사용 불가능
-객체 멤버변수는 객체메소드에서 사용 가능


클래스 변수/메소드는 클래스가 메모리에 올라갈 떄 선언
객체 변수/메소드는 객체가 생성될 떄 선언
 - 클래스 메소드가 호출 된 시점에 객체가 만들어져 있는지 안만들어져 있는지 알수 없고,
   어떤 객체의 정보를 출력해야할지 모르기 때문에 클래스 메소드에서는 객체 변수/메소드를 호출할수 없다

final : 변경이 불가능
- 변수       : 상수
 - 생성자에 final 변수를 초기화 할 수 있다. 단, 한번 초기화 한 후에는 변경할 수 없다.
 -메소드 : 메소드 오버라이딩 불가능
 -클래스 : 상속 불가능(예 : String)

다음 메뉴를 가지는 게시글 콘솔 프로그램을 만드세요.
1. 게시글 등록
2. 게시글 수정
3. 게시글 삭제
4. 게시글 목록 확인
5. 게시글 상세 확인
6. 프로그램 종료

♥♥♥♥♥♥♥♥♥12일차♥♥♥♥♥♥♥♥♥♥♥♥

조건문과 반복문에서 실행문이 1줄이면 {}를 생략할 수 있다.

자바 : 객체지향 프로그래밍 언어(oop)

전화를 걸어야한다
          절차                  vs                       객체
전화거는 기능을                         	전화를 걸수 있는 기능을 가진
만들어서 전화를 건다                   	핸드폰을 설계한다 => 클래스
                                             	설계도를 통해 핸드폰을 만든다
                                                => 객체 생성
			         	핸드폰으로 전화를 건다
				=> 객체의 메소드 호출

클래스
 - 멤버변수 : 정도
 - 멤버메소드 : 기능
 - 생성자 : 정보의 초기값 설정

멤버변수
 - 객체는 멤버변수가 될수 없다(x) = > 객체는 멤버 변수가 될 수 있다.
 - 멤버변수는 생성자에서 사용가능하다(O)
 - 멤버변수는 멤버메소드에서 사용가능하다(O)
   => 멤버 변수는 클래스내에서 사용 가능하다.
        단, 객체변수나 클래스 변수냐에 따라 불가능 할 수도 있다.
- 일반적으로 접근제한자를 private으로 한다.
  => getter와 setter가 필요하다 => 이클립스에서 클릭으로 생성 가능

멤버 메소드
 - 기능, 매개변수, 리턴타입을 정리한 후 메소드를 선언하고, 구현
 - 오버로딩
   - 동일한 이름을 가진 메소드가 여러개 있는 경우
   - 매개변수가 다를 때

생성자
 - 멤버변수를 초기화 하는 곳
 - new 연산자를 통해서 객체를 생성한 후 호출이 된다
   => 객체.생성자()로 호출할 수 없다.
   => 마음대로 부를 수 없다
 - 이름이 클래스와 같다
 - 오버로딩
   -생성자가 여러개 있는 경우
   - 매개변수가 다를 떄 
 - this()를 이용하여 다른 생성자를 호출할 수 있다.
 - 클래스에 생성자가 하나도 없을 때, 기분 생성자가 자동으로 만들어진다.
 - 클래스에 생성자가 하나라도 있을 때 기본 생성자가 만들어지지 않는다.

클래스 변수/메소드				객체변수/메소드
-클래스가 메모리에 올랐을 떄 생성		-객체를 생성할때 생성
- 객체 생성 없이 호출이 가능			-객체를 꼭 생성해야 호출가능
-static이 붙음				-static 안붙음
-클래스 변수는 모든 객체가 공유		-객체 변수는 각 객체마다 변수가 존재
 => 객체가 n개라면 클래스 변수는 1개		 => 객체가 n개라면 객체 변수는 n개


-클래스 메소드를 객체 메소드에서 호출할 수 있다 O 
-클래스 변수를 객체 메소드에서 호출할 수 있다 O
-객체 메소드 클래스 메소드에서 호출할 수 있다 X
-객체 변수를 클래스 메소드에서 호출할 수 있다 X
-클래스 변수를 클래스 메소드에서 호출할 수 있다 O
-객체 변수를 객체 메소드에서 호출할 수 있다 O

final : 바꿀수 없는
- 변수 : 상수
- 메소드 : 오버라이딩 불가능
- 클래스 : 상속할 수 없음

클래스 상속 : 부모 클래스의 멤버 변수/ 메소드를 물려 받는 것
 -접근제한자가 private이면 물려받지 못함
 => 부모 클래스에 해당 변수에 대한 getter와 setter를 만들어서 자식 클래스에서 사용
 - 접금제한자가 default 이면 같은 패키지가 아닌 경우 물려받지 못함
 - 접근제한자가 public, protected이면 물려받음

class 자식클래스명 extends 부모클래스명{

}
 - 코드의 중복을 제거할 수 있다
 - 부모클래스에 구현된 메소드를 사용할 수 있기 때문에 효율이 좋다

상속을 할 수 있는 경우
 - A는 B이다가 성립하면 상속할 수 있다.
   - A : 자식클래스 
     B : 부모클래스 
 - 사람은 동물이다 O => 동물 클래스를 상속받아 사람 클래스를 만들 수 있다
 - 동물은 사람이다 X => 사람 클래스를 상속받아 동물 클래스로 만들 수 없다.
 - 스마트폰은 폰이다 O
   - 스마트폰 : 자식
   -      폰    : 부모
-스마트폰은 카메라이다 X
-사각형은 도형이다 o
-삼각형은 도형이다 o
-원은 도형이다 o
  - 부모 : 도형
  - 자식 : 삼각형 사각형 원

상속받은 자식클래스의 생성자
 - 자식클래스의 생성자를 호출하면 자식 클래스의 생성자가 실행되는데,
    자식 클래스 생성자 안에 부모생성자가 있어서 먼저 호출이 된다.
 - 자식클래스의 생성자안에 부모클래스의 생성자가 없으면 부모클래스의 기본 생성자가
   자동으로 호출 됨
 - 부모 클래스의 생성자는 super()를 통해 호출하면 본인 클래스의 생성자 this()를 호출할
  수 없다.

super				vs 		this
- 부모 클래스의 객체를 의미 				-내 클래스의 객체를 의미
- 생성자 : super()					-생성자 : this()
-멤버 호출					-멤버 호출
 super.멤버변수					 this.멤버변수
 super.멤버메소드{}					 this.멤버메소드{}
 - 단 접근제한자에 따라 부모 클래스의		  	 -접근 제한자 상관없이 호출가능
   메소드를 호출할 수 없을 수 있다.


♥♥♥♥♥♥♥♥♥13일차♥♥♥♥♥♥♥♥♥♥♥♥

클래스 상속  
 - 부모클래스의 멤버변수/메소드를 자식 클래스가 물려받는것
 =>접근제한자가 private이면 물려받을수 X
 - 부모 클래스의 멤버변수/메소드를 선언하지 않아도 사용할 수 있다
 - 자식 클래스가 A, 부모 클래스 B
class A extends B{

}
 - A는 B이다가 성립하면 상속이 가능 : is a 관례
 - 모든 클래스는 부모 클래스의 생성자를 호출한다.
 - super()를 통해 직접 호출하지 않으면 부모클래스의 기본생성자를 자동으로 호출
 - 부모클래스는 하나만 존재 => 부모가 존재할 수 있고, 조부모가 존재할 수 있지만
   부모가 2분씩 있을 수 없다.
 
메소드 재정의(메소드오버라이드/오버라이딩)
 - 부모클래스의 메소드를 자식 클래스가 재정의 하는 것
 - 부모클래스의 메소드와 선언이 똑같은 메소드를 입력하고 구현부를 수정

final : 수정할 수 없는
 - 변수 : 상수
 - 메소드 : 오버라이딩 불가능 => 자식클래스에서 해당 메소드를 재정의 할 수 없다.
 - 클래스 : 상속할 수 없다 => 해당 클래스는 부모클래스가 될 수 없다.

class A{}
class AA extends A{}
class AAA extends AA{}

class B{
	public int num;
	public void print(){
		System.out.println("안녕");
	}

}
class C{
	public int num;
	public void print(){
		System.out.println("Hi);
	}
}
class BC extends B, C{} // 에러발생

class D{
	public void print(){}
	public void print(int num){}
}

클래스간 타입 변환(p.333)
 - 자동으로 가능한 경우
   -자식클래스의 객체를 부모클래스로 변환시키는 경우 자동으로 가능
자식클래스 객체1 = new 자식클래스();
부모클래스 객체2 = 객체1;
- 명시적으로 가능한 경우
  - 부모 클래스의 객체를 자식클래스로 변환시키는 경우 명시적(강제)으로 해야하는데
    항상 가능한건 아니다.
   - 부모 객체가 자식 클래스로 만들어진 경우 자식클래스로 변환시키는경우 가능
 P p = new C();
 C c = (C)p;
     - 부모 객체가 부모 클래스로 만들어진 경우 자식 클래스로 변환시킬수 없다.
 P p = new p();
 C c = (C)p;

♥♥♥♥♥♥♥♥♥♥♥14일차♥♥♥♥♥♥♥♥♥♥

클래스
 -정보를 편하게 관리하고 기능을 쉽게 사용하기 위해서
 -구성 : 필드 (멤버), 멤버 메소드, 생성자
 -메소드는 메소드 멤버 메소드 일 때와 클래스 멤버 메소드 일 때 많은 것이 많은 다를 수
   있다.
 -내부 객체 : 각 객체마다 멤버들이있다.
 -클래스 변수 : 하나의 멤버 객체를 모든가 같이 사용

상속
 -편하게 클래스를 만드려고
 -표준으로 제공되는 클래스를 상속 받기 위해
 -다형성을 이용하면 구독 나 멤버 변수를 다향하게 적용 할 수 있습니다.
 -다양한 클래스를 하나의 부모 클래스로 관리하기 위해
   => 도형 예제
 -부모 클래스에있는 멤버 변수 / 메소드를 물려받는 것
 -접근 제 한자에 따라 접근 할 수 없을 수도있다 (private)
 -오버라이드 : 부모 클래스에게 물려받은 메소드를 재정의하는 것
   -메소드 선언이 부모 클래스의 메소드와 경우

 -오버로드 : 메소드 이름의 메소드 / 생성자가 여러 개있는 경우
   -보편적 인 경우

상속
-A는 B이다
-관계입니다

포함 (멤버 변수)
-A는 B를 가지고있다
-관계가있다

생성자
-생성자는 여러개 있어도 한개 만 선택됩니다. 
-생성자는 객체를 생성 할 때 호출한다. 호출을 통해 호출 할 수 없습니다.
-생성자 이름은 클래스 명과 동일
-생성자가 하나도 기본 생성자가 자동으로 생성된다.
-리턴 타입이 없다
-생성자는 부모를 생성 할 때 호출한다.

클래스 A {
	public A () {} // 생성자
	public void A () {} // 메소드
}

이
-나를 객체
-this () : 생성자

감독자
-부모를 만들 것
-super () : 부모 클래스 생성자


♥♥♥♥♥♥♥♥♥15일차♥♥♥♥♥♥♥♥♥♥♥♥

추상클래스
 - 공통된 멤버변수(필드)와 메소드의 이름을 통일하려고 사용
 => 시간을 절약
abstract class 클래스명{
}
 - 추상 클래스를 이용하여 객체를 생성할 수 없다
 => 추상 클래스를 상속한 자식 클래스를 만든 후 객체를 생성해야 한다.
 - 추상 클래스는 추상 메소드를 생성할 수 있다
 - 추상 메소드는 선언부만 있고 구현부가 없는 메소드
 => 기능명은 있지만 구현되지 않음
 - 추상 클래스에 추상 메소드가 있으면 추상 클래스를 상속받은 자식 클래스에서
    (자식 클래스가 일반 클래스인 경우)추상 메소드를 무조건 오버라이딩해야 한다. 
 => 구현부가 없기 때문에 구현해줘야 한다
 - 추상 메소드가 있으면 일반 클래스가 될 수 없고 추상 클래스이어야 한다.
 - 


인터페이스
 - 메소드는 추상 메소드만 있을 수 있다
   => abstract라는 키워드가 없어도 자동으로 추가됨
 - 변수는 있을 수 없고 클래스 상수만 있을 수 있다
   => static final이라는 키워드가 없어도 자동으로 추가 됨
 - 매개변수의 다형성을 인터페이스를 이용해서도 적용할 수 있다.
 - 인터페이스를 이용하여 객체를 만들 수 없다
 - 인터페이스는 구현 클래스를 생성한 후 객체를 만들 수 있다.
 - 상속은 extends, 구현은 implements를 이용
 - 구현클래스는 여러개의 인터페이스를 구현할 수 있다.

- 매개변수의 다형성
  - 메소드의 매개변수를 부모클래스로 설정하면, 해당 부모 클래스를 상속받은
    자식 클래스들이 매개변수로 올 수 있다

추상 클래스                                    vs                        인터페이스





타입변환
 - 상속
 1. 자동
     자식클래스 객체1 = new 자식클래스();
     부모클래스 객체2 = 객체1;
 2. 강제
     부모클래스 객체3 = ??
     자식클래스 객체4 = 객체3

-구현
 1. 자동
     구현클래스 객체5 = new 구현클래스();
     인터페이스 객체6 = 객체5;
 2. 강제
     인터페이스 객체7 = new  구현클래스();
     구현클래스 객체8 = (구현클래스)객체7;

인터페이스의 상속
 - 클래스의 상속과는 다르게,
   인터페이스의 삭속은 다중 상속이 가능

		인터페이스 	추상클래스	인터페이스
멤버변수		 o		o		x
상수 		 o		o		o
메소드 		 o		o		x
추상메소드	 x		o		o
객체생성		 o


익명 개체
 - 일반적으로 클래스를 생성하고, 생성한 클래스를 이용하여 객체를 만듬
  => 개체의 이름이 있다
1. 자식 클래스 대신 익명 객체 사용
 - 자식 클래스가 재사용 되지 않고 딱 한군데에서 사용되는 경우 자식 클래스를
   만드는 대신 익명 객체를 만들어서 사용
2. 구현 클래스 대신 익명 객체 사용
 - 구현 클래스가 재사용 되지 않고 딱 한군데에서만 사용되는 경우 구현 클래스를
    만드는 대신 익명 객체를 만들어서 사용
class A{

}
A a = new A();

예외처리 : 예외를 처리
-예외 : 코드로 해결이 가능한 것
-오류 : 코드로 해결이 불가능한 것
-모든 예외 클래스의 조상은 Exception 클래스
-일반예외 : 컴파일 과정에서 오류가 남, 실행되지 않음
-실행예외 : 실행되는 과정에서 오류가 남, 일단 실행은 됨
-예외가 발생되었을 떄 예외처리가 안되어 있다면 프로그램이 중단됨.


실행예외의 종류
1. NullpointerExeption
-참조변수를 이요하는 경우 발생할 수 있다.
-객체나 배열을 생성하지 않고 멤버변수나 메소드를 사용하는 경우 발생
 - 해결방법
   -객체나 배열을 생성
   -멤버변수나 메소드를 호출하기전에 조건문을 이용하여 null인지 체크를 하면된다

2.ArrayindexOutOfBounsException
 - 배열을 이용할 때 발생할 수 있다
 - 잘못된 배열 번지에 접근하는 경우 발생한다
 - 해결방법
  - 배열의 번지는 0부터 arr.length보다 작다는 걸 기억하자
  - 향상된 for문을 이용해도 되는 상황이면 적극적으로 이용하자

3.NumberFormatException
  - 문자열을 숫자로 변환할때에 발생할 수 있다.
  - 문자열에 숫자가 아닌 문자들이 있는 경우 발생한다.

4.ClassCastExeption
 - 클래스 타입변환시 발생할 수 있다.
 - 해결방법
    - 조건문과 instanceof를 이용하자

♥♥♥♥♥♥♥♥♥16일차♥♥♥♥♥♥♥♥♥♥♥♥

예외 : 코드로 해결 가능한 문제들
 - 예외처리 : 예외가 발생할수 있는 코드를 예외가 발생했을 때 처리할수 있도록 작성하는 코드
 - 일반예외 : 실행되기전 컴파일에서 예외가 발생. 실행 안됨
 - 실행예외 : 실행했을 때 발생. 

예외처리 : try catch
1. 직접처리 : try catch
try{
       예외가 발생할 수 있는 코드;
}catch(예외클래스1 e){
 	예외1이 발생했을 때 실행할 코드1;	
}catch(예외클래스2 e){
 	예외2이 발생했을 때 실행할 코드2;
}catch(Exception e){
	예외1, 예외2를 제외한 모든 예외가 발생했을 때 실행할 코드3;
}finally{
	항상실행;
}
 - finally : 메소드가 종료되더라도 무조건 실행

2. 떠넘기기 :throws
-메소드에서 예외가 발생한 경우 직접 예외처리를 하지않고
 호출한 메소드에게 예외처리를 떠넘길 수 있다.
-메소드에 throws를 이용하여 해당 메소드에서 발생할 수 있는
 예외 종료들을 알려줘야 한다.
-단, 실행 예외인 경우 throws에 알려주지 않아도 됨


throw : 자바에서 정해놓은 예외가 아닌 개발자가 발생시키는 예외를 만들때 사용
-throw 예외 객체;

-실행 예외가 아닌 일반 예외는 무조건 예외처리를 해야한다.
-실행 예외는 예외처리를 안해도 프로그램은 실행 됨
-실행 예외는 RuntimeException을 상속받은 예외 클래스들이다.
 RuntimeException 포함.

Object 클래스
 - 모든 클래스의 조상
 - Object 클래스에서 제공하는 메소드를 오버라이딩해서 잘 사용해야 한다
 - equals()
   - Object클래스의 equals()는 두 객체의 주소가 같은지를 확인
   - 클래스에서 equals()를 오버라이딩해서 원하는 값을 확인하는
     메소드로 수정해야 한다
   - Object 클래스의 자식 클래스는 equals()를 오버라이딩해서
     객체의 멤버변수의 값이 같으면 같은 객체로 판별할 수 있다.

String 클래스 : 문자열 클래스

-예외
 -try catch 또는 throws를 이용하지 않고 조건문과 리턴값을 이용하여	
  예외 처리를 할 수 있다.
  하지만 메소드에 리턴값이 이미 있는 경우는 조건문과 리턴값을 이용하여
  예외처리를 할 수 없다.



-Object클래스

♥♥♥♥♥♥♥♥♥♥♥17일차♥♥♥♥♥♥♥♥♥♥

String 클래스 : 문자열 클래스
 - charAt(번지) : 문자열에서 번지에 해당하는 문자를 알려주는 메소드
   charAt(0) : 문자열에서 0번지에 해당하는 문자를 알려주는 메소드
 - equals(문자열) : 두 문자열이 같은지 알려주는 메소드
 - indexOf(문자열A) : 문자열에서 문자열A가 어디에 있는지 번지를
   알려주는 메소드, 없으면 -1
 - length() : 문자열의 길이를 알려주는 메소드
 - replace(A,B): 문자열에서 A와 일치하는 곳을 B로 교체한 문자열을
   알려주는 메소드, 원본은 바뀌지 않음
 - substring(index) : index번지부터 끝까지 부분 문자열을 생성
 - substring(begin, end) :  begin번지부터 end번지 전까지
   부분 문자열을 생성
 -toLowerCase() : 문자열을전부 대문자로
 -toUpperCase() : 문자열을전부 소문자로
 -trim() : 앞뒤 공백을 제거하는 메소드
 -valueOf(기본타입) : 기본타입값을 문자열로 변경해주는 메소드
  클래스 메소드 
 - split(패턴) : 문자열을 패턴을 기준으로 부분 문자열들로 나눈 후 배열로 만듬
 - compareTo(문자열) : 두문자열이 같은지를 비교하여 같으면 0
   다르면 사전순에 따라 1 또는 -1을 반환              
 - contains(문자열) : 해당 문자열이 포함되어있는지 아닌지 알려주는 메소드


같다
 - 일반변수 : ==
 - 참조변수 : equals();
체이닝 : 메소드를 연속해서 사용하는 것

래퍼(Wrapper)클래스
 - 기본타입을 클래스로 만든 것
 - 기본타입의 값 + null을 가질 수 있다.
 - 나중에 컬렉션 프레임워크나 제네릭 클래스에서 기본타입이 아닌
   클래스


-----------1차 시험 리눅스-----------------------
GUI : Graphical User Interface

CLI : Command-Line interface

운영체제 : 컴퓨터의 자원을 관리하기 위한 시스템
 - 윈도우 
 - 리눅스
 - 맥OS 
명령어 - 옵션
ls : 현재 폴더에 있는 파일 및 폴더를 확인하는 명령어
Is -al : 현재 폴더에 있는 파일 및 폴더를 자세히 확인하는 명령어(숨긴파일 포함)
mkdir 폴더명 : 새 폴더를 생성
cd 폴더명 : 해당 폴더로 이동
cd .. : 현재 폴더에서 상위 폴더로 이동
cd ~ : 최상위 폴더로 이동
cd /폴더명 : 절대경로에서 폴더명으로 이동
rmdir 폴더명 : 해당폴더를 삭제
hostname -I: (대문자I) 아이피 주소를 확인

♥♥♥♥♥♥♥♥♥♥♥18일차♥♥♥♥♥♥♥♥♥♥

컬렉션 프레임워크
 - 자료들을 효율적으로 관리하기 위한 것
 - List,Set,Map
 	-List와 Set은 한종류의 데이터를 관리, Map은 2종류의 데이터를 관리
	-List : 순서 보장, 중복가능
	-set : 중복 불가능, 순서를 보장하지 않음
	-Map : key과 value로 이러우짐, key는 중복 불가. value는 중복 가능
List
 -순서 보장, 중복가능
 -ArrayList
	-List의 구현 클래스
	-배열로 된 리스트
	-탐색이 빠르다
	-중간 삽입/삭제가 느리다
 -LinkedList
	-List의 구현 클래스
 	-탐색이 느리다
	-중간 삽입/삭제가 빠르다

 -자료들을 처음으로 관리하기위한 것
 -목록, 설정,지도 : 인터페이스
 -List와 Set은 한종 류의 데이터를 관리, Map은 2 종류의 데이터를 관리
 -목록 : 순서 보장, 연장 가능
 -설정 : 불가능, 순서를 보장하지 않음
-Map : key과 값으로 이루어짐. 열쇠는 불가. 값은 가능하다

목록 : 인터페이스
 -순서 보장, 가능
 -ArrayList
   -List의 구현 클래스
   -배열로 된리스트
   -탐색이 빠르다
   -중간 삽입 / 삭제가 느리다
 -LinkedList
   -List의 구현 클래스
   -연결로 된리스트
   -탐색이 느리다
   -중간 삽입 / 삭제가 빠르다

세트 : 인터페이스
 -불가능 불가능, 순서 보장 x
 -HashSet 
   -해시 코드를 이용하여 먼저 확인 한 후 equals ()를 이용하여 확인

지도
 -키와 값로 짐
 -키는 이중 불가, 값은 이중 가능
 -출력 할 때 조금 복잡
 -HashMap
   -지도 구현 클래스

♥♥♥♥♥♥♥♥♥♥♥19일차♥♥♥♥♥♥♥♥♥♥

변수
 - 변수 선언 방법
타입 변수명;
 - 기본 타입 종류와 값
   - 정수형 : int, char
   - 실수형 : double, float
A / B * C / D
A * C / (B*D)
   - 논리형 : boolean
 - 변수명 작성 규칙
   - 숫자로 시작할 수 없다
   - 예약어를 사용할 수 없다
   - 특수문자는 $와 _만 가능
   - 중복 선언이 불가능
   - 대소문자를 구별한다
 - 변수명 작성 관례(일반적으로, 대부분의 개발자들이)
   - 변수명은 소문자로 한다
   - 상수는 대문자로 한다
   - 카멜 표기법 : 변수명이 두단어이상으로 되어 있을 때 두번째 단어부터
     첫글자만 대문자로 표기하는 것
   - 클래스는 첫글자로 대문자로 한다
   - 변수명/메소드/클래스명은 의미있는 단어로 작성

 - 일반변수
   - 기본타입으로 선언한 변수
   - 값을 저장
   - ==로 비교
 - 참조변수
   - 기본타입이 아닌 배열, 클래스, 열거형등으로 선언한 변수
   - 주소를 저장
   - 클래스인경우는 equals() 메소드를 이용 하고, 
     기본타입 배열은 ==로
     클래스 배열은 equals() 메소드로 이용하고,
     열거형은 ==를 이용한다
 - 지역변수
   - 사용하는 지역이 일부(메소드 하나, 반복문 한곳 등)인 경우
 - 멤버변수
   - 클래스의 멤버로, 사용하는 지역이 클래스 안 전체인 경우
     (멤버 변수의 종류에 따라 사용 할 수 없는 메소드가 있을 수 있다)
 - 매개변수
   - 메소드를 동작시키기 위해 알려주는 정보
   - 지역변수
   - 멤버변수와 매개변수의 우선순위는 매개변수가 높다
 - 클래스 멤버 변수
   - static이 붙은 멤버변수
   - 클래스를 통해 호출
 - 객체 멤버 변수
   - static이 안붙은 멤버변수
   - 객체를 통해 호출(대부분 getter를 이용)

- 하나의 변수는 변수 종류 중 한가지에만 속한다(x)

연산자
 - 연산자 종류와 결과
 - 산술연산자
   - +,-,*,/,%
   - 정수 / 정수 => 정수가 되어서 소수점이 사라짐(정확하지 않음)
     타입 변환을 통해 (double)정수 / 정수 => 실수가 되도록 해야 한다
   - % : 나머지를 확인하는 연산자로 말로 표현했을 때 나누었을 때 나머지
     에 해당
   - 산술 연산자의 계산 결과값은 값
 - 대입 연산자
   - =
   - 오른쪽에 있는 값을 왼쪽에 저장
   - 왼쪽에는 변수가 1개 와야 한다
   - 저장, 덮어쓴다, 초기화 등의 표현
   - 대입 연산자는 값 또는 주소값
 - 증감연산자
   - ++, --
   - 최종적으로 1증가/1감소
   - 전위형 : 증가하고 동작
   - 후위형 : 동작하고 증가
   - 증감연산자 결과값은 값
 - 비교연산자
   - >, <, >=, <=, ==, !=
   - 크기 비교
   - 일반변수의 크기를 비교할 때 사용
   - 비교 연산자 결과값은 참 또는 거짓(논리 값)
   - ==와 대입연산자 =을 혼동하지 말자
 - 논리 연산자
   - &&, ||, ! 
   - && : ~하고, ~이고, 둘다 참이면 참, 나머지는 거짓
   - || : ~거나, 둘다 거짓이면 거짓, 나머지는 참
   - ! : ~ 아닌, 반대, 참이면 거짓, 거짓이면 참
   - 논리 연산자 결과값은 참 또는 거짓(논리 값)
 - 조건선택연산자
   - (조건식)?(참) : (거짓)
   - 조건식이 참이면 (참)에 해당하는 부분을 거짓이면 (거짓)에 해당하는
     부분을 실행
 - 조건식 
   - 연산 결과가 참 또는 거짓이 되는 식
 - 연산자 우선 순위
   - 우선순위는 ()가 제일 높다

조건문
 - ~하면 ... 해라
 - ~ : 조건식, ... : 실행문
 - 조문건의 종류 : if문, switch문
 - if문 
   - 모든 조건문을 다룰 수 있다
   - if문 문법
if(조건식1){
	실행문1;
} else if(조건식2){
	실행문2;
} else{
	실행문3;
}
   - if : 무조건 1개
   - else if : 0개 이상
   - else : 0개 또는 1개
   - 위의 문법에서 조건식1과 조건식2를 같이 만족하는 경우에 실행되는
     실행문은? 실행문1이 실행됨
if(조건식1); {
	실행문1;
}
 - switch문
   - 사용하는 변수(식)의 값이 제한적일 때
   - switch문법
switch(변수/식){
case 값1:
	실행문1;
	break;
case 값2:
	실행문2;
	break;
default:	
	실행문3;
}
   - break : switch문을 빠져 나오는 역할
   - switch문에서 break를 만나지 못하면 다음 실행문으로 이동

반복문
 - 규칙적인 작업을 여러번할 때 사용
 - 반복횟수, 규칙성을 찾아야 한다
 - 반복문 종류
   - for문, while문, do while문
 - for문
   - 문법으로 초기화 , 조건식, 증감식을 입력하는 위치가 있다
   - 초기화 : 반복문에서 사용하는 변수를 초기화, 생략 가능
   - 조건식 : 반복문 동작을 결정하는 곳으로 참이면 반복문 동작, 거짓이면
                 반복문 종료, 생략 가능하며 생략하면 항상 참
   - 증감식 : 조건식에서 사용하는 변수를 증가하거나 감소시킨다, 생략가능
   - 초기화, 조건식, 증감식이 반복회수를 결정한다
   - for문 문법
for(초기화 ; 조건식; 증감식){
	실행문;
}
 - while문
   - (강사는) 반복횟수가 정해져 있지 않거나, 순차적으로 증가/감소하지 않는
     경우 while문을 이용
   - while 문법
     - 조건식은 생략 불가능
while(조건식){
	실행문;
}
 - do while문
   - 무조건 한번은 실행
   - ;이 들어 간다
   - do while문 기본 문법
do{
	실행문;
}while(조건식);

- 반복문 사용시 유의 사항
  - 의도치 않은 무한루프가 생기지 않도록 주의
  - 조건식을 잘못 지정해서 실행되지 않는 경우가 생기지 않도록 주의

 - 향상된 for문
   - 배열이나 리스트일 때 향상된 for문을 사용할 수 있다.
   - 배열이나 리스트의 원소들을 전체 탐색할 때 사용
   - 향상된 for문 문법
for(타입 변수명 : 배열이나 리스트){
	실행문;
}

 - break
   - switch문/반복문을 빠져 나가는 역할
   - 반복문에서는 if문과 세트로 같이 나온다
 - contine
   - 스킵
   - for문에서는 증감식위치로 점프(스킵), while문에서는 조건식 위치로 스킵
   - if문과 세트로 같이 나옴
   - continue를 만나면 아래 코드가 있더라도 실행하지 않고 지정된 위치로
     이동

배열
 - (같은 의미) 같은 타입 변수들의 집합
 - 배열은 변수들을 효율적으로 관리하기 위해 사용
 - 배열은 참조변수
 - 배열의 시작번지 0번지부터 크기-1번지까지
 - 배열에서 번지를 잘못사용하면 ArrayIndexOutOfBounds 예외가 발생
 - 배열의 길이는 배열명.length로 알 수 있다
 - 배열은 반복문과 같이 사용 된다

클래스
 - 메소드
   - 하나의 기능을 하도록 모아놓은 코드
   - 매개변수 : 메소드를 실행하기 위해 필요한 정보
   - 리턴타입 : 메소드 실행 후 알려주는 정보
   - 메소드 선언부
리턴타입 메소드명(매개변수){}
   - 리턴값은 해당 메소드를 호출한 메소드에게 알려줌
   - 리턴값이 없는 경우 void를 사용
   - 매개변수는 값 또는 주소값을 복사해서 사용
   - 매개변수가 일반변수인 경우 원래값(메소드를 호출한 곳에서 알려준 값)
     이 변경이 안된다.
   - 매개변수가 참조변수인 경우 원래값이 변경될 수 있다.
   - 메소드 오버로딩
     - 동일한 이름의 메소드가 여러개 존재할 수 있다
     - 매개변수가 다른 경우
       - 매개변수의 갯수가 다른 경우
       - 매개변수의 타입이 다른 경우
 - 멤버변수
   - 클래스에서 나타낼 정보
   - 멤버 메소드에서 멤버변수를 이용하여 동작
   - 멤버변수는 생성자에서 초기화 할 수 있다.
   - 멤버변수가 참조변수이면 객체를 꼭 만들어 놓아야 한다.
      - 명시적 초기화 또는 생성자 또는 초기화 블록
 - 생성자
   - 멤버 변수들을 초기화 하는 곳
   - 일반적으로 접근제한자가 public
   - 이름이 클래스명과 동일
   - 리턴타입을 쓰지 않음
   - new를 이용하여 객체를 생성할 때 호출
   - 객체 생성 후 임의로 호출할 수 없다
   - 생성자 오버로딩을 통해 다양한 형태의 생성자를 만들 수 있다
   - 생성자가 없으면 기본 생성자가 만들어진다
 - 객체 선언 및 생성
클래스명 객체명 = new 클래스명();
 - 객체는 생성을 해야 멤버 메소드와 멤버 변수를 사용할 수 있다
 - 객체를 생성하지 않고 멤버 메소드와 멤버 변수를 사용하면 NullPointer
   예외가 발생한다
 - 멤버 메소드를 호출하는 방법
객체명.메소드명(매개변수);
 - 접근제한자
   - public		: 본인 + 같은 패키지 + 자식 + 다른 패키지
   - protected	: 본인 + 같은 패키지 + 자식
   - 디폴트	: 본인 + 같은 패키지
   - private	: 본인
 - static
   - 멤버 변수/메소드를 클래스 멤버 변수/메소드로 만듬
   - 클래스 변수/메소드는 모든 객체가 공유함
   - 클래스 변수/메소드는 클래스당 1개만 존재
   - static이 안붙은 멤버 변수/메소드를 객체 멤버 변수/메소드라 함
   - 객체 변수/메소드는 각 객체마다 각각 1개씩 존재
   - 클래스 변수는 객체 메소드에서 사용할 수 있다.
   - 객체 변수는 클래스 메소드에서 바로 사용할 수 없다.
   - 클래스 메소드는 객체 메소드에서 사용할 수 있다.
   - 객체 메소드는 클래스 메소드에서 바로 사용할 수 없다.
   - 클래스 변수/메소드는 객체 없이 호출 가능하지만
     객체 변수/메소드는 객체가 있어야 호출이 가능하다
 - final
   - 변할 수 없다
   - 변수    : 상수로 된다
   - 메소드 : 오버라이딩을 할 수 없다
   - 클래스 : 부모클래스가 될 수 없다

상속
 - 부모클래스의 멤버변수/메소드를 물려 받는것
 - extends 키워드를 이용해서 상속
 - 코드의 중복을 제거
 - 쉽게 클래스를 만들기 위해서
 - 서로 다른 자식 클래스들의 개체들을 부모 클래스가 쉽게 관리하기 위해서
 - 클래스 상속에서 부모는 한 클래스만 가능
 - 인터페이스 상속에서 부모는 여러 인터페이스가 가능
 - 메소드 오버라이딩
   - 부모 클래스에 있는 메소드를 자식 클래스에서 재정의 하는 것
   - 부모 클래스의 메소드 선언부가 동일해야한다.(매개변수, 리턴타입이 동일)
   - 접근제한자는 좁은 범위로 줄일 수 없다
     - 부모 클래스 메소드의 접근제한자가 public이면 해당 메소드를 
       자식 클래스에서 오버라이딩 할 때 접근제한자는 public만 가능
       디폴트, protected, private으로 변경 불가능
 - 클래스 타입변환
   - 클래스 타입 변환은 부모와 자식 관계에서 가능
   - 자동 : 자식 클래스의 객체를 부모 클래스의 객체로 변환하는 경우
Parent p = new Child();
   - 강제(조건) : 부모 클래스의 객체를 자식 클래스의 객체로 변환하는 경우
Parent p = new Child();
Child c = (Child)p;

추상클래스
 - Calendar
 - abtract를 붙여줌
 - 추상 클래스는 객체를 생성할 수 없다. 자식 클래스를 이용하여 객체를 생성
 - 추상 메소드
   - 메소드 선언부만 있고, 구현부가 없는 메소드
   - 자식 클래스에서 무조건 오버라이딩을 해야 한다(자식 클래스가 일반
     클래스인 경우)

인터페이스
 - 상수와 추상메소드로 이루어져 있다
 - 인터페이스를 이용하여 객체를 생성할 수 없다
 - 인터페이스를 이용하여 구현 클래스를 만든다. implements를 사용
 - 구현 클래스를 만들 때 여러 인터페이스를 구현해도 된다
 - 구현 클래스에서는 인터페이스에 있는 메소드들을 오버라이딩해야한다
 - 기능 명세서

익명 객체
 - 클래스를 상속받아서(인터페이스를 구현해서) 이름 있는 클래스로 만드는 
   것이 아니라 한 번 사용할 용도로 이름 없는 클래스를 만들어 객체를 
   생성하는 것
 - 익명 객체를 사용하는 경우 새로운 멤버 변수/메소드를 생성하지 않고
   부모 클래스에 있는 메소드나 인터페이스에 있는 메소드를 오버라이딩해서
   사용
A a = new A(){
	//멤버변수와
	//멤버메소드
};

예외처리
 - 프로그램이 중단되는 것 막기 위해
 - 예외 상황을 발견하고 그 상황을 해결하기 위해
 - 예외 : 코드로 해결이 가능한 부분
 - 오류 : 코드로 해결할 수 없는 부분
 - 일반 예외 : 컴파일 단계에서 확인되어 실행되지 않는 예외
 - 실행 예외 : 컴파일 단계에서 확인되지 않고 실행 과정에서 나타는 예외
 - 실행 예외는 예외처리를 하지 않아도 에러가 발생하지 않음.
   일반 예외는 예외처리를 하지 않으면 에러가 발생함
 - 배열 : ArrayIndexOutOfBounds
 - 참조 : NullPointer
 - 나누기 : Arithmetic
 - 타입변환 : ClassCast
 - 문자열을 숫자로 : NumberFormat
 - 예외처리 방법1 : try catch
try{
	예외가 발생할 수 있는 코드;
}catch(예외클래스명1 e){
	예외처리문;
}catch(예외클래스명2 e){
	예외처리문;
}finally{
	실행문;
}
   - 이때 예외클래스명1은 예외클래스명2의 조상클래스이면 안됨
   - finally는 예외처리 과정에서 메소드가 종료되도 무조건 실행 됨
 - 예외처리 방법2 : throws
   - 예외가 발생하면 직접 처리하지 않고 예외를 던져서 남이 처리하게 하는
     방법
   - 메소드 선언부에서 매개변수 옆에 throws 예외클래스명을 입력하여
     발생할 수 있는 예외를 알려줌
   - 단, 실행예외인 경우 throws를 생략할 수 있음
 - 예외 던지기 : throw
   - 자동으로 발생되는 예외가 아닌 변수의 조건에 따라 예외를 발생시키고자
     할때 사용
   - throw는 예외 객체를 던져야하기 때문에 일반적으로
     throw new 예외클래스명("예외메시지"); 형태로 던진다

기본 API클래스
 - Object
   - 모든 클래스의 조상 클래스
   - equals(), toString()
 - String
   - 문자열이 있는지 확인하는 메소드
     - indexOf()
     - contains()
   - 문자열이 같은지 확인하는 메소드 : equals()
   - 구분자를 기준으로 문자열을 추출하여 배열로 만드는 메소드: split()
   - 문자열의 길이를 확인하는 메소드 : length()
 - Math
   - 올림 : ceil()
   - 버림 : floor()
   - 반올림 : round(), rint()
   - 랜덤 : random() 
 - Date
   - 날짜를 문자열로
   - 문자열을 날짜로
 - Calender
   - 달력
   - 년, 월, 일, 시, 분, 초등 다양한 값들을 확인할 수 있다
   - 추상클래스

제네릭 클래스
 - 클래스의 멤버 변수 또는 메소드의 타입이 객체를 선언할 때 결정되는 
   클래스
 - <>로 클래스명이 필요하다. 생략하면 <Object>를 한거와 같다.

컬렉션 프레임워크
 - 인터페이스 : List, Set, Map
 - 데이터를 쉽게 관리하기 위해 만들어 놓은 인터페이스
 - List
   - 순서 보장, 중복가능
   - 구현 클래스 : ArrayList, LinkedList
   - 멤버 메소드
   - 향상된 for문을 이용할 수 있다
   - Iterator를 이용하여 값들을 가져올 수 있다.
 - Set
   - 중복 불가능, 순서 보장 x
   - 구현 클래스 : HashSet
   - 멤버 메소드
   - Iterator를 이용하여 반복문을 사용해야 값들을 가져올 수 있다
     List에 있는 get()메소드가 없기 때문에 Iterator를 이용하지 않고는
     값을 확인할 수 없다
 - Map
   - 두 종류의 데이터를 저장, key와 value
   - key는 중복 불가능
   - value는 중복 가능
   - 순서를 보장하지 않음
   - 이미 있는 key값에 중복으로 데이터를 넣으면 최신 데이터로 덮어쓴다
   - 값들을 확인하기 위해 Set으로 변환시켜야 된다
     - key값들을 Set으로 만들어서 확인
     - Entry라는 클래스를 이용하여 Set으로 만들어서 확인

♥♥♥♥♥♥♥♥♥♥♥19일차♥♥♥♥♥♥♥♥♥♥

개발 과정
요구사항 명서세
스토리보드
디자인 시안	ERD 설계
화면 구현		백엔드 개발

요구사항 명세서 
 - 프로젝트 전체 규모를 파악
 - 구현 가능 여부에 대한 논의
 - 커뮤니케이션 비용 절약
 - 프로젝트 일정 계획 수립

요구사항명세서 작성 항목
 - ID : 요구사항을 구별하기 위한 값
 - 화면명 : 어느 화면에서 구현할 기능이지 작성
 - 요구사항명 : 요구사항 설명을 요약
 - 내용 : 요구사항 상세를 작성
 - 작성날짜
 - 중요도 : 1~5, 상중하 등으로 표시
 - 버전
 - 진행사항 여부
 - 참고

좋은 요구사항 명세서의 특징
 - 요구사항 명세서를 읽은 작업자가 이해하기 쉬워야 한다.
   (혼동의 여지가 없어야한다)
 - 명확하게 작성한다
 - 하나의 요구사항에 대해 여러가지 요구사항을 작성하지 않습니다.
 - 애매한 단어를 사용하지 않는다.
   ~ 기능이 있으면 좋겠다 => ~ 기능이 필요
 - 중요한 요구하상은 표시하되 남발하지 말자
 - 동일한 용어를 사용한다
   댓글이라고 표현하면 이후에도 댓글로 표현해야지 코멘트,덧글과 같은
   단어를 같이 사용하면 안된다.

대학교에서 수강신청만(성적관리 X) 관리하는 사이트를 구축하려 한다.
해당 사이트를 구축하기 위한 요구사항 명세서를 작성하세요.























































